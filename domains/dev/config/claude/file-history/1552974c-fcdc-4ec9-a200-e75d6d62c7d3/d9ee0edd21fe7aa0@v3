package core

import (
	"context"
	"errors"

	"github.com/sansaninc/sdi-core/integrated_data/shared/bc_db"
	"github.com/sansaninc/sdi-core/shared/golang_lib/common_vo"
	"github.com/sansaninc/sdi-core/shared/golang_lib/contextx"
	"github.com/sansaninc/sdi-core/shared/golang_lib/ex"
	"github.com/sansaninc/sdi-core/shared/golang_lib/sqlxx"
)

type Repository struct {
}

func NewRepository() *Repository {
	return &Repository{}
}

var ErrNotFound = errors.New("not found")

func (r *Repository) GetLatest(ctx context.Context, accessor sqlxx.Accessor, tenantID common_vo.TenantID) (*RootEntity, error) {
	const query = `-- statistics_computation_initiation.GetLatest
SELECT id, created_at, retention_until
FROM enriched_data_statistics_computation_initiation
WHERE tenant_id = @tenant_id
ORDER BY created_at DESC
LIMIT 1`

	rows, err := sqlxx.TypedAccessor[bc_db.EnrichedDataStatisticsComputationInitiation](accessor).SelectList(
		ctx,
		query,
		struct {
			TenantID string `db:"tenant_id"`
		}{
			TenantID: tenantID.String(),
		},
		sqlxx.WithSkipAuthenticatedTenantIDCheckSelectOption(),
	)
	if err != nil {
		return nil, ex.Wrap(err)
	}

	if len(rows) == 0 {
		return nil, ex.Wrap(ErrNotFound)
	}

	return r.restore(rows[0]), nil
}

func (r *Repository) restore(row *bc_db.EnrichedDataStatisticsComputationInitiation) *RootEntity {
	return &RootEntity{
		id:             ID{value: mustParseID(row.ID)},
		createdAt:      createdAt{value: row.CreatedAt},
		retentionUntil: retentionUntil{value: row.RetentionUntil},
	}
}

func (r *Repository) Insert(ctx context.Context, tx sqlxx.Transaction, rootEntity *RootEntity) error {
	tenantID, err := contextx.GetTenantID(ctx)
	if err != nil {
		return ex.Wrap(err)
	}

	row := &bc_db.EnrichedDataStatisticsComputationInitiation{
		ID:             rootEntity.id.value.String(),
		TenantID:       tenantID.String(),
		CreatedAt:      rootEntity.createdAt.value,
		RetentionUntil: rootEntity.retentionUntil.value,
	}
	if _, err := row.Insert(ctx, tx); err != nil {
		return ex.Wrap(err)
	}

	return nil
}
