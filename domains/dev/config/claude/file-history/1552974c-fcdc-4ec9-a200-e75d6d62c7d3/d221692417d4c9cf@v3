package statistics_computation_initiation

import (
	"context"

	app_proto "github.com/sansaninc/sdi-contracts/integrated_data/enriched_data/statistics_computation_initiation/v1"
	"github.com/sansaninc/sdi-core/integrated_data/enriched_data/internal/statistics_computation_initiation/internal/core"
	"github.com/sansaninc/sdi-core/shared/golang_lib/common_vo"
	"github.com/sansaninc/sdi-core/shared/golang_lib/contextx"
	"github.com/sansaninc/sdi-core/shared/golang_lib/ex"
	"github.com/sansaninc/sdi-core/shared/golang_lib/pubsubx"
	"github.com/sansaninc/sdi-core/shared/golang_lib/sqlxx"
	"github.com/sansaninc/sdi-core/shared/golang_lib/stdx"
)

const (
	// maxTenantsPerExecution は1回の実行で処理するテナント数の上限
	// Spannerのトランザクションタイムアウトとセッション制限により制約される
	// - 導入しているバージョンのSpannerクライアントは400セッション上限がある
	// - 複数実行を想定し、1回の実行時間やリソース消費を制限するため
	// TODO: 技術的制約はInfrastructure層に置くべきだが、現状Infrastructure層がないためapplication service層に置いている
	maxTenantsPerExecution = 400
)

type addApplicationServiceV1 struct {
	connection   sqlxx.Connection
	repos        *core.Repository
	publisher    pubsubx.Publisher
	clock        stdx.Clock
	tenantClient *core.TenantAPI
	queryService *listTenantLatestInitiationQueryServiceV1
}

type addV1Args struct {
	msg *app_proto.StatisticsComputationInitiationServiceAddRequest
}

type addV1Result struct {
	tenantIDs []string
}

func (r *addV1Result) toResponse() *app_proto.StatisticsComputationInitiationServiceAddResponse {
	return &app_proto.StatisticsComputationInitiationServiceAddResponse{
		TenantIds: r.tenantIDs,
	}
}

func (s *addApplicationServiceV1) execute(ctx context.Context, _ *addV1Args) (*addV1Result, error) {
	tenantIDs, err := s.tenantClient.ListTenantID(ctx)
	if err != nil {
		return nil, ex.Wrap(err)
	}

	queryResult, err := s.queryService.query(ctx, &listTenantLatestInitiationV1Args{
		tenantIDs: tenantIDs,
	})
	if err != nil {
		return nil, ex.Wrap(err)
	}

	triggered := make([]string, 0, maxTenantsPerExecution)

	for _, tenantID := range tenantIDs {
		// 1回の実行で処理するテナント数の上限に達したら処理を停止
		// 残りのテナントは次回の実行で処理される
		if len(triggered) >= maxTenantsPerExecution {
			break
		}

		// 直近24時間以内に initiation 済みならスキップ
		latest, ok := queryResult.Items[tenantID]
		if ok && !core.ShouldInitiate(latest, s.clock) {
			continue
		}

		if err := s.executeForTenant(ctx, tenantID); err != nil {
			return nil, err
		}

		triggered = append(triggered, tenantID.String())
	}

	return &addV1Result{
		tenantIDs: triggered,
	}, nil
}

func (s *addApplicationServiceV1) executeForTenant(ctx context.Context, tenantID common_vo.TenantID) error {
	// テナント偽装
	ctx = contextx.ImpersonateTenant(ctx, tenantID)

	newRootEntity := core.NewRootEntity(s.clock)

	tx, err := s.connection.Begin(ctx)
	if err != nil {
		return ex.Wrap(err)
	}
	defer tx.Rollback(ctx)

	if err := s.repos.Insert(ctx, tx, newRootEntity); err != nil {
		return ex.Wrap(err)
	}

	event := newRootEntity.ToAddedEvent(tenantID)
	if err := s.publisher.PublishForBatch(ctx, tx, event, "statistics_computation_initiation"); err != nil {
		return ex.Wrap(err)
	}

	if err := tx.Commit(ctx); err != nil {
		return ex.Wrap(err)
	}

	return nil
}
